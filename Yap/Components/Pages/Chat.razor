@page "/"
@rendermode InteractiveServer
@inject ChatService ChatService
@inject ChatConfigService ChatConfig
@inject EmojiService EmojiService
@inject IJSRuntime JS
@inject IWebHostEnvironment Environment
@implements IAsyncDisposable

@using Yap.Models

<PageTitle>@pageTitle</PageTitle>

@if (string.IsNullOrEmpty(username))
{
    <div class="username-container">
        <h2>@welcomeMessage</h2>
        <div class="username-form">
            <input type="text" @bind="usernameInput" @bind:event="oninput"
                   placeholder="@usernamePlaceholder" class="username-input"
                   @onkeypress="HandleUsernameKeyPress" />
            <button class="join-button" @onclick="JoinChat"
                    disabled="@(string.IsNullOrWhiteSpace(usernameInput))">
                @joinButtonText
            </button>
        </div>
    </div>
}
else
{
    <div class="chat-container">
        <div class="chat-header">
            <h3>@GetCurrentViewHeader()</h3>
            <div class="header-controls">
                <span class="connection-status connected">@username</span>
                <button class="mailbox-button @(totalUnreadDMs > 0 ? "has-unread" : "")" @onclick="OpenSidebarForDMs" title="@(totalUnreadDMs > 0 ? $"{totalUnreadDMs} unread messages" : "Messages")">
                    @if (totalUnreadDMs > 0)
                    {
                        @* Filled inbox icon *@
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5v-3h3.56c.69 1.19 1.97 2 3.45 2s2.75-.81 3.45-2H19v3zm0-5h-4.99c0 1.1-.9 2-2 2s-2-.9-2-2H5V5h14v9z"/>
                        </svg>
                        <span class="mailbox-badge">@totalUnreadDMs</span>
                    }
                    else
                    {
                        @* Outline inbox icon *@
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 12h-6l-2 3h-4l-2-3H2"/>
                            <path d="M5.45 5.11L2 12v6a2 2 0 002 2h16a2 2 0 002-2v-6l-3.45-6.89A2 2 0 0016.76 4H7.24a2 2 0 00-1.79 1.11z"/>
                        </svg>
                    }
                </button>
                <button class="users-toggle" @onclick="ToggleSidebar" title="Toggle sidebar">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M14 8.00598C14 10.211 12.206 12.006 10 12.006C7.795 12.006 6 10.211 6 8.00598C6 5.80098 7.795 4.00598 10 4.00598C12.206 4.00598 14 5.80098 14 8.00598ZM2 19.006C2 15.473 5.29 13.006 10 13.006C14.711 13.006 18 15.473 18 19.006V20.006H2V19.006Z"/>
                        <path d="M20.0001 20.006H22.0001V19.006C22.0001 16.4433 20.2697 14.4415 17.5213 13.5352C19.0621 14.9127 20.0001 16.8059 20.0001 19.006V20.006Z"/>
                        <path d="M14.8834 11.9077C16.6657 11.5044 18.0001 9.9077 18.0001 8.00598C18.0001 5.96916 16.4693 4.28218 14.4971 4.0367C15.4322 5.09511 16.0001 6.48524 16.0001 8.00598C16.0001 9.44888 15.4889 10.7742 14.6378 11.8102C14.7203 11.8734 14.8022 11.9388 14.8834 11.9077Z"/>
                    </svg>
                    <span class="online-count">@onlineUsers.Count</span>
                </button>
            </div>
        </div>

        <div class="chat-main">
            <div class="messages-container">
                <div class="messages" @ref="messagesElement">
                    @if (currentDMUser == null)
                    {
                        @* Room messages *@
                        @for (int i = 0; i < messages.Count; i++)
                        {
                            var message = messages[i];
                            var isSystemMessage = message.Username == "System";
                            var showHeader = !isSystemMessage && (i == 0 || messages[i - 1].Username != message.Username);
                            var isOwnMessage = message.Username == username;
                            var isHovered = hoveredMessageId == message.Id;
                            var isEditing = editingMessageId == message.Id;

                            <div class="message-group @(isSystemMessage ? "system-message" : "") @(isHovered ? "hovered" : "")"
                                 @onmouseenter="() => OnMessageMouseEnter(message.Id)"
                                 @onmouseleave="OnMessageMouseLeave">
                                @if (showHeader)
                                {
                                    <div class="message-header">
                                        <strong class="message-username">@message.Username</strong>
                                        <span class="message-time">@message.Timestamp.ToLocalTime().ToString("HH:mm")</span>
                                    </div>
                                }
                                <div class="message-content">
                                    @if (isEditing)
                                    {
                                        <div class="edit-container">
                                            <input type="text" @bind="editContent" @bind:event="oninput"
                                                   class="edit-input" @onkeydown="HandleEditKeyDown" />
                                            <div class="edit-actions">
                                                <button class="edit-save" @onclick="SaveEdit" title="Save">‚úì</button>
                                                <button class="edit-cancel" @onclick="CancelEdit" title="Cancel">‚úï</button>
                                            </div>
                                        </div>
                                    }
                                    else if (message.HasImages)
                                    {
                                        var maxPreview = 4;
                                        var hasMore = message.ImageUrls.Count > maxPreview;
                                        var previewCount = hasMore ? maxPreview : message.ImageUrls.Count;
                                        var extraCount = message.ImageUrls.Count - maxPreview;

                                        <div class="image-gallery @GetGalleryClass(previewCount)">
                                            @for (int imgIndex = 0; imgIndex < previewCount; imgIndex++)
                                            {
                                                var idx = imgIndex;
                                                var imageUrl = message.ImageUrls[idx];
                                                var isLastPreview = hasMore && idx == maxPreview - 1;

                                                <div class="gallery-item @(isLastPreview ? "has-more" : "")"
                                                     @onclick="() => ShowGallery(message.ImageUrls, idx)">
                                                    <img src="@imageUrl" alt="Uploaded image" class="gallery-image" />
                                                    @if (isLastPreview)
                                                    {
                                                        <div class="gallery-more-overlay">+@extraCount</div>
                                                    }
                                                </div>
                                            }
                                        </div>
                                    }
                                    else
                                    {
                                        @EmojiService.ConvertEmojisToTwemoji(message.Content)
                                        @if (message.IsEdited)
                                        {
                                            <span class="edited-indicator">(edited)</span>
                                        }
                                    }
                                </div>

                                @* Reactions display *@
                                @if (message.Reactions.Count > 0)
                                {
                                    <div class="reactions-display">
                                        @foreach (var reaction in message.Reactions)
                                        {
                                            var hasReacted = reaction.Value.Contains(username);
                                            <button class="reaction-pill @(hasReacted ? "reacted" : "")"
                                                    @onclick="() => ToggleReaction(message.Id, reaction.Key)"
                                                    title="@string.Join(", ", reaction.Value)">
                                                @reaction.Key <span class="reaction-count">@reaction.Value.Count</span>
                                            </button>
                                        }
                                    </div>
                                }

                                @* Message actions popup *@
                                @if (isHovered && !isSystemMessage && !isEditing)
                                {
                                    <div class="message-actions">
                                        <button class="action-btn" @onclick="@(() => ToggleReaction(message.Id, HEART))" title="Love">‚ù§Ô∏è</button>
                                        <button class="action-btn" @onclick="@(() => ToggleReaction(message.Id, LAUGH))" title="Laugh">üòÇ</button>
                                        <button class="action-btn" @onclick="@(() => ToggleReaction(message.Id, TOUCHED))" title="Touched">ü•π</button>
                                        @if (isOwnMessage && !message.HasImages)
                                        {
                                            <button class="action-btn action-edit" @onclick="() => StartEdit(message)" title="Edit">‚úèÔ∏è</button>
                                        }
                                        @if (isOwnMessage)
                                        {
                                            <button class="action-btn action-delete" @onclick="() => DeleteMessage(message.Id)" title="Delete">üóëÔ∏è</button>
                                        }
                                    </div>
                                }
                            </div>
                        }
                    }
                    else
                    {
                        @* DM messages *@
                        @for (int i = 0; i < dmMessages.Count; i++)
                        {
                            var message = dmMessages[i];
                            var showHeader = i == 0 || dmMessages[i - 1].FromUser != message.FromUser;
                            var isOwnMessage = message.FromUser.Equals(username, StringComparison.OrdinalIgnoreCase);
                            var isHovered = hoveredDMId == message.Id;
                            var isEditing = editingDMId == message.Id;

                            <div class="message-group @(isHovered ? "hovered" : "")"
                                 @onmouseenter="() => OnDMMouseEnter(message.Id)"
                                 @onmouseleave="OnDMMouseLeave">
                                @if (showHeader)
                                {
                                    <div class="message-header">
                                        <strong class="message-username">@message.FromUser</strong>
                                        <span class="message-time">@message.Timestamp.ToLocalTime().ToString("HH:mm")</span>
                                    </div>
                                }
                                <div class="message-content">
                                    @if (isEditing)
                                    {
                                        <div class="edit-container">
                                            <input type="text" @bind="editDMContent" @bind:event="oninput"
                                                   class="edit-input" @onkeydown="HandleDMEditKeyDown" />
                                            <div class="edit-actions">
                                                <button class="edit-save" @onclick="SaveDMEdit" title="Save">‚úì</button>
                                                <button class="edit-cancel" @onclick="CancelDMEdit" title="Cancel">‚úï</button>
                                            </div>
                                        </div>
                                    }
                                    else if (message.HasImages)
                                    {
                                        var maxPreview = 4;
                                        var hasMore = message.ImageUrls.Count > maxPreview;
                                        var previewCount = hasMore ? maxPreview : message.ImageUrls.Count;
                                        var extraCount = message.ImageUrls.Count - maxPreview;

                                        <div class="image-gallery @GetGalleryClass(previewCount)">
                                            @for (int imgIndex = 0; imgIndex < previewCount; imgIndex++)
                                            {
                                                var idx = imgIndex;
                                                var imageUrl = message.ImageUrls[idx];
                                                var isLastPreview = hasMore && idx == maxPreview - 1;

                                                <div class="gallery-item @(isLastPreview ? "has-more" : "")"
                                                     @onclick="() => ShowGallery(message.ImageUrls, idx)">
                                                    <img src="@imageUrl" alt="Uploaded image" class="gallery-image" />
                                                    @if (isLastPreview)
                                                    {
                                                        <div class="gallery-more-overlay">+@extraCount</div>
                                                    }
                                                </div>
                                            }
                                        </div>
                                    }
                                    else
                                    {
                                        @EmojiService.ConvertEmojisToTwemoji(message.Content)
                                        @if (message.IsEdited)
                                        {
                                            <span class="edited-indicator">(edited)</span>
                                        }
                                    }
                                </div>

                                @* DM Message actions popup *@
                                @if (isHovered && !isEditing)
                                {
                                    <div class="message-actions">
                                        @if (isOwnMessage && !message.HasImages)
                                        {
                                            <button class="action-btn action-edit" @onclick="() => StartDMEdit(message)" title="Edit">‚úèÔ∏è</button>
                                        }
                                        @if (isOwnMessage)
                                        {
                                            <button class="action-btn action-delete" @onclick="() => DeleteDM(message.Id)" title="Delete">üóëÔ∏è</button>
                                        }
                                    </div>
                                }
                            </div>
                        }
                    }
                </div>

                <div class="message-input-container @(isDraggingOver ? "drag-over" : "")"
                     @ref="dropZoneElement"
                     @ondragenter="HandleDragEnter"
                     @ondragover="HandleDragOver"
                     @ondragover:preventDefault
                     @ondragleave="HandleDragLeave"
                     @ondrop="HandleDrop"
                     @ondrop:preventDefault>
                    <textarea @bind="messageInput" @bind:event="oninput" @bind:after="OnMessageInputChanged"
                              placeholder="@GetMessagePlaceholder()" class="message-input"
                              @onkeydown="HandleMessageKeyDown" @onkeydown:preventDefault="shouldPreventDefault"
                              rows="1" id="messageTextarea"></textarea>
                    <label class="image-upload-button" title="Upload images">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
                             stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <circle cx="8.5" cy="8.5" r="1.5"></circle>
                            <polyline points="21 15 16 10 5 21"></polyline>
                        </svg>
                        <InputFile @ref="fileInput" OnChange="HandleFileSelected" accept="image/*" multiple style="display: none;" id="fileInput" />
                    </label>
                    <button class="send-button @(string.IsNullOrWhiteSpace(messageInput) ? "disabled" : "")"
                            @onclick="SendMessage"
                            disabled="@string.IsNullOrWhiteSpace(messageInput)"
                            title="Send message">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                        </svg>
                    </button>
                </div>

                <div class="typing-indicator-container">
                    @if (!string.IsNullOrEmpty(typingIndicatorText))
                    {
                        <div class="typing-indicator">
                            <span style="display: flex; align-items: center; gap: 0.5rem; color: #72767d;">
                                <span class="typing-dots">
                                    <span class="dot"></span>
                                    <span class="dot"></span>
                                    <span class="dot"></span>
                                </span>
                                <span>@typingIndicatorText</span>
                            </span>
                        </div>
                    }
                </div>
            </div>

            <div class="users-sidebar @(sidebarOpen ? "sidebar-open" : "")">
                @* Rooms section *@
                <div class="sidebar-section">
                    <h4>ROOMS</h4>
                    <div class="rooms-list">
                        @foreach (var room in rooms)
                        {
                            var isActive = currentDMUser == null && currentRoomId == room.Id;
                            <div class="room-item @(isActive ? "active" : "")" @onclick="() => SwitchToRoom(room.Id)">
                                <span class="room-icon">#</span>
                                <span class="room-name">@room.Name</span>
                                @if (isAdmin && !room.IsDefault)
                                {
                                    <button class="room-delete" @onclick="() => DeleteRoom(room.Id)" @onclick:stopPropagation="true" title="Delete room">√ó</button>
                                }
                            </div>
                        }
                        @if (isAdmin)
                        {
                            @if (showNewRoomInput)
                            {
                                <div class="new-room-input">
                                    <input type="text" @bind="newRoomName" @bind:event="oninput"
                                           placeholder="room name" class="room-name-input"
                                           @onkeypress="HandleNewRoomKeyPress" />
                                    <button class="room-create-btn" @onclick="CreateRoom" title="Create">‚úì</button>
                                    <button class="room-cancel-btn" @onclick="CancelNewRoom" title="Cancel">‚úï</button>
                                </div>
                            }
                            else
                            {
                                <div class="room-item add-room" @onclick="ShowNewRoomInput">
                                    <span class="room-icon">+</span>
                                    <span class="room-name">Add Room</span>
                                </div>
                            }
                        }
                    </div>
                </div>

                @* Online users section *@
                <div class="sidebar-section">
                    <h4>@onlineUsersHeader</h4>
                    <div class="users-list">
                        @foreach (var user in GetSortedUsers())
                        {
                            var isCurrentUser = user.Equals(username, StringComparison.OrdinalIgnoreCase);
                            var isUserAdmin = ChatService.IsAdmin(user);
                            var userUnreadCount = isCurrentUser ? 0 : GetUnreadDMCount(user);
                            var isActiveDM = currentDMUser != null && currentDMUser.Equals(user, StringComparison.OrdinalIgnoreCase);

                            <div class="user-item @(isCurrentUser ? "current-user" : "") @(isActiveDM ? "active-dm" : "")"
                                 @onclick="() => OpenDM(user)"
                                 title="@(isCurrentUser ? "You" : $"Message {user}")">
                                <span class="user-name">@user</span>
                                @if (isUserAdmin)
                                {
                                    <span class="admin-badge" title="Admin">üõ°Ô∏è</span>
                                }
                                @if (userUnreadCount > 0)
                                {
                                    <span class="dm-unread-badge">@userUnreadCount</span>
                                }
                            </div>
                        }
                    </div>
                </div>
            </div>
        </div>
        <div class="sidebar-backdrop @(sidebarOpen ? "show" : "")" @onclick="ToggleSidebar"></div>
    </div>
}

@if (showImageModal)
{
    <div class="image-modal" @onclick="CloseImageModal">
        @if (modalGallery.Count > 1)
        {
            <button class="modal-nav prev" @onclick="PrevImage" @onclick:stopPropagation="true" title="Previous">‚Äπ</button>
        }
        <img src="@modalGallery[modalImageIndex]" alt="Full size image" @onclick:stopPropagation="true" />
        @if (modalGallery.Count > 1)
        {
            <button class="modal-nav next" @onclick="NextImage" @onclick:stopPropagation="true" title="Next">‚Ä∫</button>
            <div class="modal-counter">@(modalImageIndex + 1) / @modalGallery.Count</div>
        }
        <button class="modal-close" @onclick="CloseImageModal" @onclick:stopPropagation="true" title="Close">√ó</button>
    </div>
}

@code {
    // Reaction emoji constants
    private const string HEART = "‚ù§Ô∏è";
    private const string LAUGH = "üòÇ";
    private const string TOUCHED = "ü•π";

    private string circuitId = Guid.NewGuid().ToString();

    // State
    private string username = "";
    private string usernameInput = "";
    private string messageInput = "";
    private List<ChatMessage> messages = new();
    private List<string> onlineUsers = new();
    private List<string> typingUsers = new();
    private ElementReference messagesElement;
    private ElementReference dropZoneElement;
    private InputFile? fileInput;
    private bool showImageModal = false;
    private List<string> modalGallery = new();
    private int modalImageIndex = 0;
    private bool sidebarOpen = false;
    private System.Timers.Timer? typingTimer;
    private bool isTyping = false;

    // Room state
    private List<Room> rooms = new();
    private Guid currentRoomId;
    private bool isAdmin = false;
    private bool showNewRoomInput = false;
    private string newRoomName = "";

    // DM state
    private string? currentDMUser = null;
    private List<DirectMessage> dmMessages = new();
    private List<string> dmTypingUsers = new();
    private Dictionary<string, int> dmUnreadCounts = new();

    // Message actions state (room)
    private Guid? hoveredMessageId = null;
    private Guid? editingMessageId = null;
    private string editContent = "";

    // Message actions state (DM)
    private Guid? hoveredDMId = null;
    private Guid? editingDMId = null;
    private string editDMContent = "";

    // Drag and drop state
    private bool isDraggingOver = false;

    // Tab notifications
    private int unreadCount = 0;
    private string pageTitle = "Yap";
    private string currentContext = "";

    // Total unread DMs for mailbox icon
    private int totalUnreadDMs = 0;

    // UI Text
    private string welcomeMessage = "";
    private string joinButtonText = "";
    private string usernamePlaceholder = "";
    private string messagePlaceholder = "";
    private string connectionStatus = "";
    private string onlineUsersHeader = "";
    private string typingIndicatorText = "";

    protected override void OnInitialized()
    {
        welcomeMessage = ChatConfig.GetRandomWelcomeMessage();
        joinButtonText = ChatConfig.GetRandomJoinButtonText();
        usernamePlaceholder = ChatConfig.GetRandomUsernamePlaceholder();
        messagePlaceholder = ChatConfig.GetRandomMessagePlaceholder();
        connectionStatus = ChatConfig.GetRandomConnectionStatus(true);
        UpdateOnlineUsersHeader();
        pageTitle = ChatConfig.ProjectName;
    }

    private string GetCurrentViewHeader()
    {
        if (currentDMUser != null)
            return $"DM with {currentDMUser}";

        var room = rooms.FirstOrDefault(r => r.Id == currentRoomId);
        return room != null ? $"# {room.Name}" : ChatConfig.GetRandomRoomHeader();
    }

    private string GetMessagePlaceholder()
    {
        if (currentDMUser != null)
            return $"Message @{currentDMUser}";
        return messagePlaceholder;
    }

    private async Task HandleUsernameKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await JoinChat();
    }

    private bool shouldPreventDefault = false;

    private async Task HandleMessageKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            shouldPreventDefault = true;
            await SendMessage();
            await JS.InvokeVoidAsync("resetTextareaHeight", "messageTextarea");
        }
        else
        {
            shouldPreventDefault = false;
            // Auto-resize on next tick after content changes
            await JS.InvokeVoidAsync("autoResizeTextarea", "messageTextarea");
        }
    }

    private async Task JoinChat()
    {
        if (string.IsNullOrWhiteSpace(usernameInput)) return;

        username = usernameInput.Trim();

        // Subscribe to events
        ChatService.OnMessageReceived += HandleMessageReceived;
        ChatService.OnMessageUpdated += HandleMessageUpdated;
        ChatService.OnMessageDeleted += HandleMessageDeleted;
        ChatService.OnReactionChanged += HandleReactionChanged;
        ChatService.OnUserChanged += HandleUserChanged;
        ChatService.OnUsersListChanged += HandleUsersListChanged;
        ChatService.OnTypingUsersChanged += HandleTypingUsersChanged;
        ChatService.OnRoomCreated += HandleRoomCreated;
        ChatService.OnRoomDeleted += HandleRoomDeleted;
        ChatService.OnAdminChanged += HandleAdminChanged;
        ChatService.OnDirectMessageReceived += HandleDirectMessageReceived;
        ChatService.OnDirectMessageUpdated += HandleDirectMessageUpdated;
        ChatService.OnDirectMessageDeleted += HandleDirectMessageDeleted;
        ChatService.OnDMTypingUsersChanged += HandleDMTypingUsersChanged;

        // Load rooms
        rooms = ChatService.GetRooms();
        currentRoomId = ChatService.LobbyId;

        // Load room history
        messages = ChatService.GetRoomMessages(currentRoomId).ToList();
        onlineUsers = ChatService.GetOnlineUsers();
        UpdateOnlineUsersHeader();

        // Join chat
        await ChatService.AddUserAsync(circuitId, username);

        // Check if we're admin
        isAdmin = ChatService.IsAdmin(username);

        // Refresh users after join (to include ourselves)
        onlineUsers = ChatService.GetOnlineUsers();
        UpdateOnlineUsersHeader();

        // Setup tab notifications
        await SetupTabNotifications();
        await UpdatePageTitle();

        await InvokeAsync(StateHasChanged);
        await ScrollToBottom();

        // Setup drag-drop zone
        await SetupDropZone();
    }

    #region Room Management

    private async Task SwitchToRoom(Guid roomId)
    {
        if (currentRoomId == roomId && currentDMUser == null) return;

        currentDMUser = null;
        currentRoomId = roomId;
        messages = ChatService.GetRoomMessages(roomId).ToList();
        typingUsers = ChatService.GetTypingUsers(roomId);
        UpdateTypingIndicator();

        // Reset unread count when switching
        unreadCount = 0;
        await UpdatePageTitle();

        // Auto-close sidebar on mobile
        sidebarOpen = false;

        await InvokeAsync(StateHasChanged);
        await ScrollToBottom();
    }

    private void ShowNewRoomInput()
    {
        showNewRoomInput = true;
        newRoomName = "";
    }

    private void CancelNewRoom()
    {
        showNewRoomInput = false;
        newRoomName = "";
    }

    private async Task HandleNewRoomKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await CreateRoom();
        else if (e.Key == "Escape") CancelNewRoom();
    }

    private async Task CreateRoom()
    {
        if (string.IsNullOrWhiteSpace(newRoomName)) return;

        var room = await ChatService.CreateRoomAsync(username, newRoomName);
        if (room != null)
        {
            showNewRoomInput = false;
            newRoomName = "";
        }
    }

    private async Task DeleteRoom(Guid roomId)
    {
        await ChatService.DeleteRoomAsync(username, roomId);
    }

    #endregion

    #region DM Management

    private async Task OpenDM(string targetUser)
    {
        if (targetUser.Equals(username, StringComparison.OrdinalIgnoreCase)) return;

        currentDMUser = targetUser;
        dmMessages = ChatService.GetDirectMessages(username, targetUser).ToList();
        dmTypingUsers = ChatService.GetDMTypingUsers(username, targetUser);
        UpdateTypingIndicator();

        // Mark messages as read
        ChatService.MarkDMsAsRead(username, targetUser);
        dmUnreadCounts[targetUser.ToLowerInvariant()] = 0;
        UpdateTotalUnreadDMs();

        // Reset unread count
        unreadCount = 0;
        await UpdatePageTitle();

        // Auto-close sidebar on mobile
        sidebarOpen = false;

        await InvokeAsync(StateHasChanged);
        await ScrollToBottom();
    }

    private int GetUnreadDMCount(string fromUser)
    {
        var key = fromUser.ToLowerInvariant();
        return dmUnreadCounts.TryGetValue(key, out var count) ? count : 0;
    }

    private void UpdateTotalUnreadDMs()
    {
        totalUnreadDMs = dmUnreadCounts.Values.Sum();
    }

    private void OpenSidebarForDMs()
    {
        sidebarOpen = true;
    }

    /// <summary>
    /// Gets users sorted by: unread first (by last message time), then others by last message time
    /// </summary>
    private IEnumerable<string> GetSortedUsers()
    {
        // Separate current user from others
        var currentUserList = onlineUsers.Where(u => u.Equals(username, StringComparison.OrdinalIgnoreCase));
        var otherUsers = onlineUsers.Where(u => !u.Equals(username, StringComparison.OrdinalIgnoreCase)).ToList();

        // Sort others: unread first, then by last DM timestamp descending
        var sorted = otherUsers
            .Select(u => new
            {
                User = u,
                UnreadCount = GetUnreadDMCount(u),
                LastDM = ChatService.GetLastDMTimestamp(username, u)
            })
            .OrderByDescending(x => x.UnreadCount > 0) // Unread first
            .ThenByDescending(x => x.LastDM ?? DateTime.MinValue) // Most recent DM
            .ThenBy(x => x.User) // Alphabetical fallback
            .Select(x => x.User);

        // Current user stays at top
        return currentUserList.Concat(sorted);
    }

    #endregion

    #region Event Handlers (Room)

    private async Task HandleMessageReceived(ChatMessage message)
    {
        await InvokeAsync(async () =>
        {
            // Only add if it's for the current room
            if (message.RoomId == currentRoomId && currentDMUser == null)
            {
                messages.Add(message);
                StateHasChanged();
                await ScrollToBottom();
            }

            // Handle notification for room messages (no sound, just count)
            if (message.Username != username && message.Username != "System" && currentDMUser == null)
            {
                await HandleNewMessageNotification(message.Username, isDM: false);
            }
        });
    }

    private async Task HandleMessageUpdated(ChatMessage message)
    {
        await InvokeAsync(() =>
        {
            if (message.RoomId == currentRoomId && currentDMUser == null)
            {
                var index = messages.FindIndex(m => m.Id == message.Id);
                if (index >= 0)
                {
                    messages[index] = message;
                }
                StateHasChanged();
            }
            return Task.CompletedTask;
        });
    }

    private async Task HandleMessageDeleted(Guid messageId, Guid roomId)
    {
        await InvokeAsync(() =>
        {
            if (roomId == currentRoomId && currentDMUser == null)
            {
                messages.RemoveAll(m => m.Id == messageId);
                StateHasChanged();
            }
            return Task.CompletedTask;
        });
    }

    private async Task HandleReactionChanged(ChatMessage message)
    {
        await InvokeAsync(() =>
        {
            if (message.RoomId == currentRoomId && currentDMUser == null)
            {
                var index = messages.FindIndex(m => m.Id == message.Id);
                if (index >= 0)
                {
                    messages[index] = message;
                }
                StateHasChanged();
            }
            return Task.CompletedTask;
        });
    }

    private async Task HandleUserChanged(string user, bool isJoining)
    {
        await InvokeAsync(() =>
        {
            // System message for lobby
            if (currentRoomId == ChatService.LobbyId && currentDMUser == null)
            {
                messages.Add(new ChatMessage(
                    ChatService.LobbyId,
                    "System",
                    ChatConfig.GetRandomSystemMessage(user, isJoining),
                    DateTime.UtcNow
                ));
                StateHasChanged();
            }
            return Task.CompletedTask;
        });
    }

    private async Task HandleUsersListChanged()
    {
        await InvokeAsync(async () =>
        {
            onlineUsers = ChatService.GetOnlineUsers();
            UpdateOnlineUsersHeader();

            // If viewing DM with someone who left, go back to room
            if (currentDMUser != null && !onlineUsers.Any(u => u.Equals(currentDMUser, StringComparison.OrdinalIgnoreCase)))
            {
                currentDMUser = null;
                dmMessages.Clear();
                messages = ChatService.GetRoomMessages(currentRoomId).ToList();
                await UpdatePageTitle();
            }

            StateHasChanged();
        });
    }

    private async Task HandleTypingUsersChanged(Guid roomId)
    {
        await InvokeAsync(() =>
        {
            if (roomId == currentRoomId && currentDMUser == null)
            {
                typingUsers = ChatService.GetTypingUsers(roomId);
                UpdateTypingIndicator();
                StateHasChanged();
            }
            return Task.CompletedTask;
        });
    }

    private async Task HandleRoomCreated(Room room)
    {
        await InvokeAsync(() =>
        {
            rooms = ChatService.GetRooms();
            StateHasChanged();
            return Task.CompletedTask;
        });
    }

    private async Task HandleRoomDeleted(Guid roomId)
    {
        await InvokeAsync(() =>
        {
            rooms = ChatService.GetRooms();

            // If we were in the deleted room, switch to lobby
            if (currentRoomId == roomId)
            {
                currentRoomId = ChatService.LobbyId;
                messages = ChatService.GetRoomMessages(currentRoomId).ToList();
            }

            StateHasChanged();
            return Task.CompletedTask;
        });
    }

    private async Task HandleAdminChanged(string? adminUser)
    {
        await InvokeAsync(() =>
        {
            isAdmin = ChatService.IsAdmin(username);
            StateHasChanged();
            return Task.CompletedTask;
        });
    }

    #endregion

    #region Event Handlers (DM)

    private async Task HandleDirectMessageReceived(DirectMessage message)
    {
        await InvokeAsync(async () =>
        {
            var isForMe = message.ToUser.Equals(username, StringComparison.OrdinalIgnoreCase) ||
                          message.FromUser.Equals(username, StringComparison.OrdinalIgnoreCase);

            if (!isForMe) return;

            var otherUser = message.FromUser.Equals(username, StringComparison.OrdinalIgnoreCase)
                ? message.ToUser
                : message.FromUser;

            // If this DM is currently open, add to view
            if (currentDMUser != null && currentDMUser.Equals(otherUser, StringComparison.OrdinalIgnoreCase))
            {
                dmMessages.Add(message);
                ChatService.MarkDMsAsRead(username, otherUser);
                StateHasChanged();
                await ScrollToBottom();
            }
            else if (message.ToUser.Equals(username, StringComparison.OrdinalIgnoreCase))
            {
                // Increment unread count for this sender
                var key = otherUser.ToLowerInvariant();
                if (!dmUnreadCounts.ContainsKey(key))
                    dmUnreadCounts[key] = 0;
                dmUnreadCounts[key]++;
                UpdateTotalUnreadDMs();
                StateHasChanged();
            }

            // Handle notification for DMs (with sound!)
            if (!message.FromUser.Equals(username, StringComparison.OrdinalIgnoreCase))
            {
                await HandleNewMessageNotification(message.FromUser, isDM: true);
            }
        });
    }

    private async Task HandleDirectMessageUpdated(DirectMessage message)
    {
        await InvokeAsync(() =>
        {
            var otherUser = message.FromUser.Equals(username, StringComparison.OrdinalIgnoreCase)
                ? message.ToUser
                : message.FromUser;

            if (currentDMUser != null && currentDMUser.Equals(otherUser, StringComparison.OrdinalIgnoreCase))
            {
                var index = dmMessages.FindIndex(m => m.Id == message.Id);
                if (index >= 0)
                {
                    dmMessages[index] = message;
                }
                StateHasChanged();
            }
            return Task.CompletedTask;
        });
    }

    private async Task HandleDirectMessageDeleted(Guid messageId, string conversationKey)
    {
        await InvokeAsync(() =>
        {
            if (currentDMUser != null)
            {
                var key = DirectMessage.GetConversationKey(username, currentDMUser);
                if (key == conversationKey)
                {
                    dmMessages.RemoveAll(m => m.Id == messageId);
                    StateHasChanged();
                }
            }
            return Task.CompletedTask;
        });
    }

    private async Task HandleDMTypingUsersChanged(string conversationKey)
    {
        await InvokeAsync(() =>
        {
            if (currentDMUser != null)
            {
                var key = DirectMessage.GetConversationKey(username, currentDMUser);
                if (key == conversationKey)
                {
                    dmTypingUsers = ChatService.GetDMTypingUsers(username, currentDMUser);
                    UpdateTypingIndicator();
                    StateHasChanged();
                }
            }
            return Task.CompletedTask;
        });
    }

    #endregion

    #region Send Messages

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(messageInput)) return;

        if (currentDMUser != null)
        {
            await ChatService.SendDirectMessageAsync(username, currentDMUser, messageInput);
        }
        else
        {
            await ChatService.SendMessageAsync(currentRoomId, username, messageInput);
        }

        messageInput = "";
        await StopTyping();
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        var files = e.GetMultipleFiles(10);
        if (files.Count == 0) return;

        var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".gif", ".webp" };
        var imageUrls = new List<string>();

        try
        {
            var uploadsFolder = Path.Combine(Environment.WebRootPath, "uploads");
            Directory.CreateDirectory(uploadsFolder);

            foreach (var file in files)
            {
                var extension = Path.GetExtension(file.Name).ToLowerInvariant();
                if (!allowedExtensions.Contains(extension)) continue;
                if (file.Size > 100 * 1024 * 1024) continue;

                var uniqueFileName = $"{Guid.NewGuid()}{extension}";
                var filePath = Path.Combine(uploadsFolder, uniqueFileName);

                await using var stream = new FileStream(filePath, FileMode.Create);
                await file.OpenReadStream(maxAllowedSize: 100 * 1024 * 1024).CopyToAsync(stream);

                imageUrls.Add($"/uploads/{uniqueFileName}");
            }

            if (imageUrls.Count > 0)
            {
                if (currentDMUser != null)
                {
                    await ChatService.SendDirectMessageAsync(username, currentDMUser, "", imageUrls);
                }
                else
                {
                    await ChatService.SendMessageAsync(currentRoomId, username, "", imageUrls);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error uploading files: {ex.Message}");
        }
    }

    #endregion

    #region Drag and Drop

    private void HandleDragEnter(DragEventArgs e) => isDraggingOver = true;
    private void HandleDragOver(DragEventArgs e) => isDraggingOver = true;
    private void HandleDragLeave(DragEventArgs e) => isDraggingOver = false;
    private void HandleDrop(DragEventArgs e) => isDraggingOver = false;

    #endregion

    #region Message Actions (Room)

    private string GetGalleryClass(int imageCount) => imageCount switch
    {
        1 => "gallery-single",
        2 => "gallery-double",
        _ => "gallery-grid"
    };

    private void OnMessageMouseEnter(Guid messageId) => hoveredMessageId = messageId;
    private void OnMessageMouseLeave() => hoveredMessageId = null;

    private async Task ToggleReaction(Guid messageId, string emoji)
    {
        await ChatService.ToggleReactionAsync(messageId, currentRoomId, username, emoji);
    }

    private void StartEdit(ChatMessage message)
    {
        editingMessageId = message.Id;
        editContent = message.Content;
    }

    private async Task SaveEdit()
    {
        if (editingMessageId.HasValue && !string.IsNullOrWhiteSpace(editContent))
        {
            await ChatService.EditMessageAsync(editingMessageId.Value, currentRoomId, username, editContent);
        }
        CancelEdit();
    }

    private void CancelEdit()
    {
        editingMessageId = null;
        editContent = "";
    }

    private async Task HandleEditKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await SaveEdit();
        else if (e.Key == "Escape") CancelEdit();
    }

    private async Task DeleteMessage(Guid messageId)
    {
        await ChatService.DeleteMessageAsync(messageId, currentRoomId, username);
    }

    #endregion

    #region Message Actions (DM)

    private void OnDMMouseEnter(Guid messageId) => hoveredDMId = messageId;
    private void OnDMMouseLeave() => hoveredDMId = null;

    private void StartDMEdit(DirectMessage message)
    {
        editingDMId = message.Id;
        editDMContent = message.Content;
    }

    private async Task SaveDMEdit()
    {
        if (editingDMId.HasValue && !string.IsNullOrWhiteSpace(editDMContent) && currentDMUser != null)
        {
            await ChatService.EditDirectMessageAsync(editingDMId.Value, username, currentDMUser, editDMContent);
        }
        CancelDMEdit();
    }

    private void CancelDMEdit()
    {
        editingDMId = null;
        editDMContent = "";
    }

    private async Task HandleDMEditKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await SaveDMEdit();
        else if (e.Key == "Escape") CancelDMEdit();
    }

    private async Task DeleteDM(Guid messageId)
    {
        if (currentDMUser != null)
        {
            await ChatService.DeleteDirectMessageAsync(messageId, username, currentDMUser);
        }
    }

    #endregion

    #region Typing Indicators

    private Task OnMessageInputChanged() => HandleTypingChangeAsync(messageInput);

    private async Task HandleTypingChangeAsync(string currentValue)
    {
        if (!string.IsNullOrWhiteSpace(currentValue) && !isTyping)
        {
            await StartTyping();
        }
        else if (string.IsNullOrWhiteSpace(currentValue) && isTyping)
        {
            await StopTyping();
        }

        typingTimer?.Stop();
        typingTimer?.Dispose();

        if (!string.IsNullOrWhiteSpace(currentValue))
        {
            typingTimer = new System.Timers.Timer(3000);
            typingTimer.Elapsed += async (s, e) =>
            {
                await StopTyping();
                typingTimer?.Dispose();
            };
            typingTimer.Start();
        }
    }

    private async Task StartTyping()
    {
        if (!isTyping)
        {
            isTyping = true;
            if (currentDMUser != null)
            {
                await ChatService.StartDMTypingAsync(username, currentDMUser);
            }
            else
            {
                await ChatService.StartTypingAsync(currentRoomId, username);
            }
        }
    }

    private async Task StopTyping()
    {
        if (isTyping)
        {
            isTyping = false;
            if (currentDMUser != null)
            {
                await ChatService.StopDMTypingAsync(username, currentDMUser);
            }
            else
            {
                await ChatService.StopTypingAsync(currentRoomId, username);
            }
            typingTimer?.Stop();
            typingTimer?.Dispose();
        }
    }

    #endregion

    #region Notifications

    private async Task SetupDropZone()
    {
        try { await JS.InvokeVoidAsync("setupDropZone", dropZoneElement, "fileInput"); } catch { }
    }

    private async Task SetupTabNotifications()
    {
        try { await JS.InvokeVoidAsync("setupVisibilityListener", DotNetObjectReference.Create(this)); } catch { }
    }

    private async Task HandleNewMessageNotification(string messageUser, bool isDM)
    {
        try
        {
            var isVisible = await JS.InvokeAsync<bool>("isPageVisible");
            if (!isVisible)
            {
                unreadCount++;
                var title = $"({unreadCount}) {ChatConfig.ProjectName} | {currentContext}";

                if (isDM)
                {
                    // DMs get sound
                    await JS.InvokeVoidAsync("notifyNewMessage", title);
                }
                else
                {
                    // Room messages just update title
                    await JS.InvokeVoidAsync("setDocumentTitle", title);
                }
            }
        }
        catch { }
    }

    [JSInvokable]
    public async Task OnPageBecameVisible()
    {
        if (unreadCount > 0)
        {
            unreadCount = 0;
            await UpdatePageTitle();
            await InvokeAsync(StateHasChanged);
        }
    }

    #endregion

    #region UI Helpers

    private async Task ScrollToBottom()
    {
        try { await JS.InvokeVoidAsync("scrollToBottom", messagesElement); } catch { }
    }

    private async Task ShowGallery(List<string> gallery, int startIndex)
    {
        modalGallery = gallery;
        modalImageIndex = startIndex;
        showImageModal = true;
        await SetupModalKeyboard();
    }

    private async Task CloseImageModal()
    {
        showImageModal = false;
        modalGallery = new();
        modalImageIndex = 0;
        await RemoveModalKeyboard();
    }

    private void NextImage()
    {
        if (modalGallery.Count > 0)
            modalImageIndex = (modalImageIndex + 1) % modalGallery.Count;
    }

    private void PrevImage()
    {
        if (modalGallery.Count > 0)
            modalImageIndex = (modalImageIndex - 1 + modalGallery.Count) % modalGallery.Count;
    }

    [JSInvokable]
    public async Task CloseModalFromJs()
    {
        await InvokeAsync(async () => { await CloseImageModal(); StateHasChanged(); });
    }

    [JSInvokable]
    public void NextImageFromJs() => InvokeAsync(() => { NextImage(); StateHasChanged(); });

    [JSInvokable]
    public void PrevImageFromJs() => InvokeAsync(() => { PrevImage(); StateHasChanged(); });

    private async Task SetupModalKeyboard()
    {
        try { await JS.InvokeVoidAsync("setupModalKeyboard", DotNetObjectReference.Create(this)); } catch { }
    }

    private async Task RemoveModalKeyboard()
    {
        try { await JS.InvokeVoidAsync("removeModalKeyboard"); } catch { }
    }

    private void ToggleSidebar() => sidebarOpen = !sidebarOpen;

    private void UpdateOnlineUsersHeader() =>
        onlineUsersHeader = ChatConfig.GetRandomOnlineUsersHeader(onlineUsers.Count);

    private async Task UpdatePageTitle()
    {
        if (currentDMUser != null)
        {
            currentContext = currentDMUser;
        }
        else
        {
            var room = rooms.FirstOrDefault(r => r.Id == currentRoomId);
            currentContext = room?.Name ?? "lobby";
        }

        var title = unreadCount > 0
            ? $"({unreadCount}) {ChatConfig.ProjectName} | {currentContext}"
            : $"{ChatConfig.ProjectName} | {currentContext}";

        pageTitle = title;
        try { await JS.InvokeVoidAsync("setDocumentTitle", title); } catch { }
    }

    private void UpdateTypingIndicator()
    {
        if (currentDMUser != null)
        {
            // DM typing - filter out self
            var others = dmTypingUsers.Where(u => !u.Equals(username, StringComparison.OrdinalIgnoreCase)).ToList();
            typingIndicatorText = others.Count > 0 ? $"{string.Join(", ", others)} is typing..." : "";
        }
        else
        {
            typingIndicatorText = ChatConfig.GetRandomTypingIndicator(typingUsers, username);
        }
    }

    #endregion

    public async ValueTask DisposeAsync()
    {
        typingTimer?.Stop();
        typingTimer?.Dispose();

        if (!string.IsNullOrEmpty(username))
        {
            ChatService.OnMessageReceived -= HandleMessageReceived;
            ChatService.OnMessageUpdated -= HandleMessageUpdated;
            ChatService.OnMessageDeleted -= HandleMessageDeleted;
            ChatService.OnReactionChanged -= HandleReactionChanged;
            ChatService.OnUserChanged -= HandleUserChanged;
            ChatService.OnUsersListChanged -= HandleUsersListChanged;
            ChatService.OnTypingUsersChanged -= HandleTypingUsersChanged;
            ChatService.OnRoomCreated -= HandleRoomCreated;
            ChatService.OnRoomDeleted -= HandleRoomDeleted;
            ChatService.OnAdminChanged -= HandleAdminChanged;
            ChatService.OnDirectMessageReceived -= HandleDirectMessageReceived;
            ChatService.OnDirectMessageUpdated -= HandleDirectMessageUpdated;
            ChatService.OnDirectMessageDeleted -= HandleDirectMessageDeleted;
            ChatService.OnDMTypingUsersChanged -= HandleDMTypingUsersChanged;

            if (isTyping)
            {
                if (currentDMUser != null)
                    await ChatService.StopDMTypingAsync(username, currentDMUser);
                else
                    await ChatService.StopTypingAsync(currentRoomId, username);
            }
            await ChatService.RemoveUserAsync(circuitId);
        }
    }
}
