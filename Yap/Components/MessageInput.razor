@inject ChatService ChatService
@inject ChatConfigService ChatConfig
@inject UserStateService UserState
@inject IJSRuntime JS
@inject IWebHostEnvironment Environment
@implements IAsyncDisposable

<div class="message-input-container @(isDraggingOver ? "drag-over" : "")"
     @ref="dropZoneElement"
     @ondragenter="HandleDragEnter"
     @ondragover="HandleDragOver"
     @ondragover:preventDefault
     @ondragleave="HandleDragLeave"
     @ondrop="HandleDrop"
     @ondrop:preventDefault>
    <textarea @bind="messageText" @bind:event="oninput" @bind:after="OnInputChangedInternal"
              placeholder="@placeholder" class="message-input"
              @onkeydown="HandleKeyDown" @onkeydown:preventDefault="shouldPreventDefault"
              rows="1" id="@TextareaId"></textarea>
    <label class="image-upload-button" title="Upload images">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
             stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <circle cx="8.5" cy="8.5" r="1.5"></circle>
            <polyline points="21 15 16 10 5 21"></polyline>
        </svg>
        <InputFile OnChange="HandleFileSelected" accept="image/*" multiple style="display: none;" id="@FileInputId" />
    </label>
    <button class="send-button @(string.IsNullOrWhiteSpace(messageText) ? "disabled" : "")"
            @onclick="HandleSend"
            disabled="@string.IsNullOrWhiteSpace(messageText)"
            title="Send message">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
        </svg>
    </button>
</div>

<div class="typing-indicator-container">
    @if (isUploading)
    {
        <div class="typing-indicator upload-indicator">
            <span style="display: flex; align-items: center; gap: 0.5rem; color: #5865f2;">
                <span class="typing-dots">
                    <span class="dot upload-dot"></span>
                    <span class="dot upload-dot"></span>
                    <span class="dot upload-dot"></span>
                </span>
                <span>Uploading @uploadingCount image@(uploadingCount > 1 ? "s" : "")...</span>
            </span>
        </div>
    }
    else if (!string.IsNullOrEmpty(typingIndicatorText))
    {
        <div class="typing-indicator">
            <span style="display: flex; align-items: center; gap: 0.5rem; color: #72767d;">
                <span class="typing-dots">
                    <span class="dot"></span>
                    <span class="dot"></span>
                    <span class="dot"></span>
                </span>
                <span>@typingIndicatorText</span>
            </span>
        </div>
    }
</div>

@code {
    // Context parameters - one or the other will be set
    [Parameter] public Guid? RoomId { get; set; }
    [Parameter] public string? DmUser { get; set; }

    private string Username => UserState.Username ?? "";
    private bool IsRoomContext => RoomId.HasValue;
    private bool IsDmContext => !string.IsNullOrEmpty(DmUser);

    // Internal state
    private ElementReference dropZoneElement;
    private bool isDraggingOver = false;
    private bool shouldPreventDefault = false;
    private string messageText = "";
    private string placeholder = "";
    private string typingIndicatorText = "";
    private bool isTyping = false;
    private bool isUploading = false;
    private int uploadingCount = 0;
    private System.Timers.Timer? typingTimer;

    // Unique IDs for this instance
    private string TextareaId = $"messageTextarea_{Guid.NewGuid():N}";
    private string FileInputId = $"fileInput_{Guid.NewGuid():N}";
    private bool isTouchDevice = false;

    protected override void OnInitialized()
    {
        UpdatePlaceholder();

        // Subscribe to typing events
        if (IsRoomContext)
        {
            ChatService.OnTypingUsersChanged += HandleTypingUsersChanged;
        }
        else if (IsDmContext)
        {
            ChatService.OnDMTypingUsersChanged += HandleDMTypingUsersChanged;
        }

        UpdateTypingIndicator();
    }

    protected override void OnParametersSet()
    {
        UpdatePlaceholder();
        UpdateTypingIndicator();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try { await JS.InvokeVoidAsync("setupDropZone", dropZoneElement, FileInputId); } catch { }
            try { isTouchDevice = await JS.InvokeAsync<bool>("isTouchDevice"); } catch { }
        }
    }

    private void UpdatePlaceholder()
    {
        if (IsDmContext)
        {
            placeholder = $"Message @{DmUser}";
        }
        else
        {
            placeholder = ChatConfig.GetRandomMessagePlaceholder();
        }
    }

    #region Typing Indicator

    private void UpdateTypingIndicator()
    {
        if (IsRoomContext && RoomId.HasValue)
        {
            var typingUsers = ChatService.GetTypingUsers(RoomId.Value);
            typingIndicatorText = ChatConfig.GetRandomTypingIndicator(typingUsers, Username);
        }
        else if (IsDmContext && !string.IsNullOrEmpty(DmUser))
        {
            var typingUsers = ChatService.GetDMTypingUsers(Username, DmUser);
            var others = typingUsers.Where(u => !u.Equals(Username, StringComparison.OrdinalIgnoreCase)).ToList();
            typingIndicatorText = others.Count > 0 ? $"{string.Join(", ", others)} is typing..." : "";
        }
        else
        {
            typingIndicatorText = "";
        }
    }

    private async Task HandleTypingUsersChanged(Guid roomId)
    {
        if (IsRoomContext && RoomId == roomId)
        {
            await InvokeAsync(() =>
            {
                UpdateTypingIndicator();
                StateHasChanged();
            });
        }
    }

    private async Task HandleDMTypingUsersChanged(string conversationKey)
    {
        if (IsDmContext && !string.IsNullOrEmpty(DmUser))
        {
            var key = DirectMessage.GetConversationKey(Username, DmUser);
            if (key == conversationKey)
            {
                await InvokeAsync(() =>
                {
                    UpdateTypingIndicator();
                    StateHasChanged();
                });
            }
        }
    }

    private async Task StartTypingAsync()
    {
        if (isTyping) return;
        isTyping = true;

        if (IsRoomContext && RoomId.HasValue)
        {
            await ChatService.StartTypingAsync(RoomId.Value, Username);
        }
        else if (IsDmContext && !string.IsNullOrEmpty(DmUser))
        {
            await ChatService.StartDMTypingAsync(Username, DmUser);
        }
    }

    private async Task StopTypingAsync()
    {
        if (!isTyping) return;
        isTyping = false;

        if (IsRoomContext && RoomId.HasValue)
        {
            await ChatService.StopTypingAsync(RoomId.Value, Username);
        }
        else if (IsDmContext && !string.IsNullOrEmpty(DmUser))
        {
            await ChatService.StopDMTypingAsync(Username, DmUser);
        }

        typingTimer?.Stop();
        typingTimer?.Dispose();
        typingTimer = null;
    }

    #endregion

    #region Input Handling

    private async Task OnInputChangedInternal()
    {
        await JS.InvokeVoidAsync("autoResizeTextarea", TextareaId);

        // Handle typing state
        if (!string.IsNullOrWhiteSpace(messageText) && !isTyping)
        {
            await StartTypingAsync();
        }
        else if (string.IsNullOrWhiteSpace(messageText) && isTyping)
        {
            await StopTypingAsync();
        }

        // Reset typing timer
        typingTimer?.Stop();
        typingTimer?.Dispose();

        if (!string.IsNullOrWhiteSpace(messageText))
        {
            typingTimer = new System.Timers.Timer(3000);
            typingTimer.Elapsed += async (s, e) =>
            {
                await StopTypingAsync();
            };
            typingTimer.Start();
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        // On touch devices, Enter creates newline (use send button to send)
        // On desktop, Enter sends message (Shift+Enter for newline)
        if (e.Key == "Enter" && !e.ShiftKey && !isTouchDevice)
        {
            shouldPreventDefault = true;
            await HandleSend();
            shouldPreventDefault = false;
        }
    }

    private async Task HandleSend()
    {
        if (string.IsNullOrWhiteSpace(messageText)) return;

        var content = messageText;
        messageText = "";

        // Reset textarea height after clearing content
        try { await JS.InvokeVoidAsync("resetTextareaHeight", TextareaId); } catch { }

        if (IsRoomContext && RoomId.HasValue)
        {
            await ChatService.SendMessageAsync(RoomId.Value, Username, content);
        }
        else if (IsDmContext && !string.IsNullOrEmpty(DmUser))
        {
            await ChatService.SendDirectMessageAsync(Username, DmUser, content);
        }

        await StopTypingAsync();
    }

    #endregion

    #region File Upload

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        var files = e.GetMultipleFiles(10);
        if (files.Count == 0) return;

        var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".gif", ".webp" };
        var validFiles = files.Where(f =>
            allowedExtensions.Contains(Path.GetExtension(f.Name).ToLowerInvariant()) &&
            f.Size <= 100 * 1024 * 1024).ToList();

        if (validFiles.Count == 0) return;

        // Show upload indicator
        isUploading = true;
        uploadingCount = validFiles.Count;
        StateHasChanged();

        var imageUrls = new List<string>();

        try
        {
            var uploadsFolder = Path.Combine(Environment.WebRootPath, "uploads");
            Directory.CreateDirectory(uploadsFolder);

            foreach (var file in validFiles)
            {
                var extension = Path.GetExtension(file.Name).ToLowerInvariant();
                var uniqueFileName = $"{Guid.NewGuid()}{extension}";
                var filePath = Path.Combine(uploadsFolder, uniqueFileName);

                await using var stream = new FileStream(filePath, FileMode.Create);
                await file.OpenReadStream(maxAllowedSize: 100 * 1024 * 1024).CopyToAsync(stream);

                imageUrls.Add($"/uploads/{uniqueFileName}");
            }

            if (imageUrls.Count > 0)
            {
                if (IsRoomContext && RoomId.HasValue)
                {
                    await ChatService.SendMessageAsync(RoomId.Value, Username, "", imageUrls);
                }
                else if (IsDmContext && !string.IsNullOrEmpty(DmUser))
                {
                    await ChatService.SendDirectMessageAsync(Username, DmUser, "", imageUrls);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error uploading files: {ex.Message}");
        }
        finally
        {
            // Hide upload indicator
            isUploading = false;
            uploadingCount = 0;
            StateHasChanged();
        }
    }

    #endregion

    #region Drag and Drop

    private void HandleDragEnter(DragEventArgs e) => isDraggingOver = true;
    private void HandleDragOver(DragEventArgs e) => isDraggingOver = true;
    private void HandleDragLeave(DragEventArgs e) => isDraggingOver = false;
    private void HandleDrop(DragEventArgs e) => isDraggingOver = false;

    #endregion

    public async ValueTask DisposeAsync()
    {
        typingTimer?.Stop();
        typingTimer?.Dispose();

        // Unsubscribe from events
        ChatService.OnTypingUsersChanged -= HandleTypingUsersChanged;
        ChatService.OnDMTypingUsersChanged -= HandleDMTypingUsersChanged;

        // Stop typing if we were
        if (isTyping)
        {
            await StopTypingAsync();
        }
    }
}
